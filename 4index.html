<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Merge Game 2.4</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* --- –°–¢–ò–õ–ò –ò–ù–¢–ï–†–§–ï–ô–°–ê --- */
        body { margin: 0; padding: 0; overflow: hidden; background: #121212; font-family: 'Segoe UI', sans-serif; touch-action: none; color: white; -webkit-tap-highlight-color: transparent; }
        #game-container { position: relative; width: 100%; height: 100vh; }

        /* –°–õ–û–ò */
        .layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .interactive { pointer-events: auto; }

        /* HUD (–í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å) */
        #hud {
            display: flex; justify-content: space-between; align-items: flex-start;
            padding: 15px; box-sizing: border-box; z-index: 5;
            position: absolute; top: 0; left: 0; width: 100%;
            pointer-events: none; 
        }

        #hud > * { pointer-events: auto; }

        /* –°—á–µ—Ç —Å–ª–µ–≤–∞ */
        .score-box {
            background: rgba(0,0,0,0.6);
            padding: 10px 15px;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .score-val { font-size: 22px; font-weight: bold; color: #fff; }

        /* –ë–ª–æ–∫ "–°–ª–µ–¥—É—é—â–∏–π" */
        .next-box {
            display: flex; align-items: center; gap: 8px;
            font-size: 13px; color: #ccc;
            border-top: 1px solid rgba(255,255,255,0.2);
            padding-top: 5px; margin-top: 2px;
        }
        .next-circle {
            width: 20px; height: 20px;
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 14px;
            background: #333;
        }

        /* –ö–Ω–æ–ø–∫–∞ –ë–ê–§–§–ê */
        #buff-container {
            display: flex; flex-direction: column; align-items: center;
        }

        #buff-btn {
            width: 50px; height: 50px;
            border-radius: 50%;
            background: #333;
            border: 2px solid #555;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px;
            cursor: pointer;
            position: relative;
            transition: transform 0.1s;
            overflow: visible; /* –ß—Ç–æ–±—ã –∑–Ω–∞—á–æ–∫ –∫–æ–ª-–≤–∞ –Ω–µ –æ–±—Ä–µ–∑–∞–ª—Å—è */
            user-select: none;
        }

        /* –°—á–µ—Ç—á–∏–∫ –∑–∞—Ä—è–¥–æ–≤ */
        #buff-count-badge {
            position: absolute;
            top: -5px; right: -5px;
            background: red; color: white;
            font-size: 12px; font-weight: bold;
            width: 20px; height: 20px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            border: 2px solid #121212;
            z-index: 10;
            opacity: 0; transition: opacity 0.3s;
        }
        #buff-count-badge.visible { opacity: 1; }

        /* –ü—Ä–æ–≥—Ä–µ—Å—Å –±–∞—Ä */
        #buff-progress {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 0%;
            background: rgba(255, 204, 0, 0.6);
            transition: height 0.3s;
            z-index: 1; border-radius: 0 0 50px 50px;
        }
        #buff-icon { z-index: 2; position: relative; }

        #buff-btn.ready {
            background: #444; border-color: #ffcc00; color: #fff;
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.3);
        }
        #buff-btn.active-mode {
            background: #ffcc00; color: #000;
            animation: pulse 1.0s infinite;
        }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        /* –ú–ï–ù–Æ */
        .menu-overlay {
            background: rgba(0,0,0,0.95); z-index: 20; display: flex; flex-direction: column;
            align-items: center; justify-content: center; backdrop-filter: blur(5px);
        }
        .hidden { display: none !important; }

        h1 { margin-bottom: 30px; font-size: 40px; background: -webkit-linear-gradient(#eee, #333); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }

        .menu-btn {
            background: #333; color: white; border: 1px solid #555;
            width: 200px; padding: 15px; margin: 10px; border-radius: 12px;
            font-size: 18px; cursor: pointer; transition: 0.2s;
        }
        .menu-btn:active { transform: scale(0.95); }
        .btn-primary { background: #0088cc; border: none; font-weight: bold; }

        /* –°–ø–∏—Å–∫–∏ */
        .scroll-list {
            width: 80%; max-height: 50%; overflow-y: auto;
            background: #222; border-radius: 10px; padding: 10px; margin-bottom: 20px;
        }
        .list-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 15px; border-bottom: 1px solid #333; cursor: pointer;
        }
        .list-item.selected { background: #004466; }

        /* –†–µ–∂–∏–º —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è */
        .destroy-mode { cursor: crosshair !important; }
        .destroy-mode #game-container { border: 4px solid red; box-sizing: border-box; }
    </style>
</head>
<body>

<div id="game-container">
    <!-- –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ -->
    <div id="main-menu" class="layer interactive menu-overlay">
        <h1>MEME DROP</h1>
        <button class="menu-btn btn-primary" onclick="Game.start()">–ò–ì–†–ê–¢–¨</button>
        <button class="menu-btn" onclick="Menu.showSkins()">–°–ö–ò–ù–´</button>
        <button class="menu-btn" onclick="Menu.showLeaderboard()">–†–ï–ö–û–†–î–´</button>
    </div>

    <!-- –ú–ï–ù–Æ –°–ö–ò–ù–û–í -->
    <div id="skins-menu" class="layer interactive menu-overlay hidden">
        <h2>–í–´–ë–û–† –°–ö–ò–ù–ê</h2>
        <div class="scroll-list" id="skins-list"></div>
        <button class="menu-btn" onclick="Menu.backToMain()">–ù–ê–ó–ê–î</button>
    </div>

    <!-- –¢–ê–ë–õ–ò–¶–ê –õ–ò–î–ï–†–û–í -->
    <div id="leaderboard-menu" class="layer interactive menu-overlay hidden">
        <h2>–¢–û–ü –ò–ì–†–û–ö–û–í</h2>
        <div class="scroll-list" id="leaderboard-list"></div>
        <button class="menu-btn" onclick="Menu.backToMain()">–ù–ê–ó–ê–î</button>
    </div>

    <!-- –ú–ï–ù–Æ GAME OVER -->
    <div id="game-over-menu" class="layer interactive menu-overlay hidden">
        <h1 style="-webkit-text-fill-color: red;">GAME OVER</h1>
        <p>–°—á–µ—Ç: <span id="final-score">0</span></p>
        <button class="menu-btn btn-primary" onclick="location.reload()">–ó–ê–ù–û–í–û</button>
        <button class="menu-btn" onclick="Menu.backToMain()">–ú–ï–ù–Æ</button>
    </div>

    <!-- HUD –ò–ì–†–´ -->
    <div id="hud" class="layer hidden">
        <!-- –°–ß–ï–¢ –∏ NEXT -->
        <div class="score-box">
            <div class="score-val">üèÜ <span id="score-val">0</span></div>
            <div class="next-box">
                <span>–î–∞–ª–µ–µ:</span>
                <div class="next-circle" id="next-ball-icon">?</div>
            </div>
        </div>

        <!-- –ú–û–õ–û–¢–û–ö (–°–ø—Ä–∞–≤–∞) -->
        <div id="buff-container">
            <div id="buff-btn" onclick="Game.activateBuff()" ontouchstart="event.stopPropagation()">
                <div id="buff-progress"></div>
                <span id="buff-icon">üî®</span>
                <div id="buff-count-badge">1</div>
            </div>
            <div style="font-size:10px; margin-top:5px; opacity:0.7">2500 pts</div>
        </div>
    </div>
</div>

<script>
    /* ==========================================
       –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø
       ========================================== */
    const SOUNDS_CFG = { merge: null, drop: null, gameover: null };

    const SKINS_DB = {
        'memes': {
            name: '–ú–µ–º—ã (Default)',
            type: 'emoji',
            levels: [
                { color: '#FFD700', label: 'ü§°', score: 2 },
                { color: '#FFA500', label: 'üí©', score: 4 },
                { color: '#FF4500', label: 'üêπ', score: 8 },
                { color: '#DC143C', label: 'ü™ô', score: 16 },
                { color: '#C71585', label: 'üí∏', score: 32 },
                { color: '#8A2BE2', label: 'üöô', score: 64 },
                { color: '#4169E1', label: 'üíé', score: 128 },
                { color: '#00BFFF', label: 'üëë', score: 256 },
                { color: '#00FA9A', label: 'üóø', score: 512 }
            ]
        },
        'fruits': {
            name: '–§—Ä—É–∫—Ç—ã',
            type: 'emoji', 
            path: '', 
            levels: [
                { color: '#F00', label: 'üçí', score: 2 },
                { color: '#F00', label: 'üçì', score: 4 },
                { color: '#800080', label: 'üçá', score: 8 },
                { color: '#FFA500', label: 'üçä', score: 16 },
                { color: '#FFA500', label: 'ü•≠', score: 32 },
                { color: '#FF0000', label: 'üçé', score: 64 },
                { color: '#FFFF00', label: 'üçê', score: 128 },
                { color: '#FFC0CB', label: 'üçë', score: 256 },
                { color: '#008000', label: 'üçâ', score: 512 }
            ]
        }
    };

    /* ==========================================
       –î–í–ò–ñ–û–ö
       ========================================== */
    let currentSkin = 'memes';
    let engine, render, runner;
    let ground, leftW, rightW;
    let score = 0;

    // –ë–ê–§–§–´ (–ù–ê–ö–û–ü–ò–¢–ï–õ–¨–ù–ê–Ø –°–ò–°–¢–ï–ú–ê)
    let hammersUsed = 0; // –°–∫–æ–ª—å–∫–æ –º–æ–ª–æ—Ç–∫–æ–≤ –º—ã –ø–æ—Ç—Ä–∞—Ç–∏–ª–∏
    const SCORE_PER_HAMMER = 2500;

    let isBuffActive = false;
    let gameActive = false;
    let currentBall = null;
    let canDrop = true;
    let upcomingBallIndex = 0; 

    let W = window.innerWidth;
    let H = window.innerHeight;

    // –†–ê–ó–ú–ï–†–´ (-10% –æ—Ç –≤–µ—Ä—Å–∏–∏ 2.3)
    const BALL_SIZES = [18, 27, 36, 45, 54, 63, 72, 81, 90];

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function stopPropagation(e) { e.stopPropagation(); }
    document.getElementById('hud').addEventListener('mousedown', stopPropagation);
    document.getElementById('hud').addEventListener('touchstart', stopPropagation);
    document.querySelectorAll('.menu-overlay').forEach(el => {
        el.addEventListener('mousedown', stopPropagation);
        el.addEventListener('touchstart', stopPropagation);
    });

    const Menu = {
        hideAll: () => {
            document.querySelectorAll('.menu-overlay').forEach(el => el.classList.add('hidden'));
        },
        backToMain: () => {
            Menu.hideAll();
            document.getElementById('main-menu').classList.remove('hidden');
        },
        showSkins: () => {
            Menu.hideAll();
            document.getElementById('skins-menu').classList.remove('hidden');
            const list = document.getElementById('skins-list');
            list.innerHTML = '';
            for (let key in SKINS_DB) {
                const skin = SKINS_DB[key];
                const div = document.createElement('div');
                div.className = `list-item ${currentSkin === key ? 'selected' : ''}`;
                div.innerHTML = `<span>${skin.name}</span> <span>${skin.levels[0].label}</span>`;
                div.onclick = () => {
                    currentSkin = key;
                    localStorage.setItem('selectedSkin', key);
                    Menu.showSkins();
                };
                list.appendChild(div);
            }
        },
        showLeaderboard: () => {
            Menu.hideAll();
            document.getElementById('leaderboard-menu').classList.remove('hidden');
            const list = document.getElementById('leaderboard-list');
            let records = JSON.parse(localStorage.getItem('leaderboard')) || [];
            records.sort((a,b) => b.score - a.score);
            list.innerHTML = '';
            if(records.length === 0) list.innerHTML = '<div style="padding:10px;text-align:center">–ù–µ—Ç –∑–∞–ø–∏—Å–µ–π</div>';
            records.slice(0, 10).forEach((rec, i) => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.innerHTML = `<div><span class="rank">#${i+1}</span> ${rec.name}</div> <div>${rec.score}</div>`;
                list.appendChild(div);
            });
        },
        showGameOver: () => {
            gameActive = false;
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-menu').classList.remove('hidden');
            let records = JSON.parse(localStorage.getItem('leaderboard')) || [];
            let name = "–ò–≥—Ä–æ–∫"; 
            records.push({name: name, score: score, date: new Date()});
            localStorage.setItem('leaderboard', JSON.stringify(records));
        }
    };

    const Game = {
        start: () => {
            Menu.hideAll();
            document.getElementById('hud').classList.remove('hidden');
            const savedSkin = localStorage.getItem('selectedSkin');
            if(savedSkin && SKINS_DB[savedSkin]) currentSkin = savedSkin;

            Game.initPhysics();
            score = 0;
            hammersUsed = 0;
            isBuffActive = false;

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ü–ï–†–í–´–ô "—Å–ª–µ–¥—É—é—â–∏–π" —à–∞—Ä (–¢–û–õ–¨–ö–û 0, 1, 2)
            upcomingBallIndex = Math.floor(Math.random() * 3); 

            Game.updateUI();
            gameActive = true;
            Game.spawnNext();
        },

        initPhysics: () => {
            if(engine) {
                Matter.World.clear(engine.world);
                Matter.Engine.clear(engine);
                if(render) { render.canvas.remove(); render.canvas = null; render.context = null; }
                if(runner) Matter.Runner.stop(runner);
            }
            W = window.innerWidth;
            H = window.innerHeight;

            engine = Matter.Engine.create();
            render = Matter.Render.create({
                element: document.getElementById('game-container'),
                engine: engine,
                options: { width: W, height: H, wireframes: false, background: 'transparent' }
            });

            const wallOpts = { isStatic: true, render: { fillStyle: '#333' } };
            ground = Matter.Bodies.rectangle(W/2, H + 50, W, 100, wallOpts); 
            leftW = Matter.Bodies.rectangle(0, H/2, 20, H, wallOpts);
            rightW = Matter.Bodies.rectangle(W, H/2, 20, H, wallOpts);

            Matter.World.add(engine.world, [ground, leftW, rightW]);

            Matter.Events.on(render, 'afterRender', Game.renderCustomSkins);
            Matter.Events.on(engine, 'collisionStart', Game.handleCollisions);

            runner = Matter.Runner.create();
            Matter.Runner.run(runner, engine);
            Matter.Render.run(render);

            window.addEventListener('mousedown', Game.handleInput);
            window.addEventListener('touchstart', Game.handleInput, { passive: false });
            window.addEventListener('mousemove', Game.moveBall);
            window.addEventListener('touchmove', Game.moveBall, { passive: false });
            window.addEventListener('resize', Game.handleResize);
        },

        handleResize: () => {
            W = window.innerWidth;
            H = window.innerHeight;
            render.canvas.width = W;
            render.canvas.height = H;
            Matter.Body.setPosition(ground, { x: W/2, y: H + 50 });
            Matter.Body.setPosition(rightW, { x: W, y: H/2 });
        },

        spawnNext: () => {
            if(!gameActive) return;

            const indexToSpawn = upcomingBallIndex;

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª–µ–¥—É—é—â–∏–π (–¢–û–õ–¨–ö–û –£–†–û–í–ù–ò 0, 1, 2)
            upcomingBallIndex = Math.floor(Math.random() * 3);

            const skin = SKINS_DB[currentSkin];
            const nextLevelData = skin.levels[upcomingBallIndex];
            const nextIconEl = document.getElementById('next-ball-icon');
            nextIconEl.innerText = nextLevelData.label;
            nextIconEl.style.backgroundColor = nextLevelData.color;

            const size = BALL_SIZES[indexToSpawn];
            const levelData = skin.levels[indexToSpawn];

            currentBall = Matter.Bodies.circle(W/2, 60, size, {
                isStatic: true,
                label: indexToSpawn,
                render: { fillStyle: levelData.color }
            });
            Matter.World.add(engine.world, currentBall);
            canDrop = true;
        },

        moveBall: (e) => {
            if(canDrop && currentBall && !isBuffActive) {
                let x = (e.touches ? e.touches[0].clientX : e.clientX);
                x = Math.max(30, Math.min(x, W - 30));
                Matter.Body.setPosition(currentBall, { x: x, y: 60 });
            }
        },

        handleInput: (e) => {
            if(!gameActive) return;
            if(e.target.closest('#hud') || e.target.closest('.menu-overlay')) return;

            // –ú–û–õ–û–¢–û–ö (–£–ù–ò–ß–¢–û–ñ–ï–ù–ò–ï)
            if(isBuffActive) {
                const x = (e.touches ? e.touches[0].clientX : e.clientX);
                const y = (e.touches ? e.touches[0].clientY : e.clientY);

                const bodies = Matter.Composite.allBodies(engine.world);
                const clickedBody = bodies.find(b => Matter.Bounds.contains(b.bounds, {x:x, y:y}) && !b.isStatic);

                if(clickedBody) {
                    Matter.World.remove(engine.world, clickedBody);

                    // –ü–æ—Ç—Ä–∞—Ç–∏–ª–∏ –º–æ–ª–æ—Ç–æ–∫
                    hammersUsed++;
                    isBuffActive = false;

                    Game.exitBuffMode();
                    Game.updateUI();
                }
                return;
            }

            // –ë–†–û–°–û–ö
            if(canDrop && currentBall) {
                let x = (e.touches ? e.touches[0].clientX : e.clientX);
                x = Math.max(30, Math.min(x, W - 30));
                Matter.Body.setPosition(currentBall, { x: x, y: 60 });
                Matter.Body.setStatic(currentBall, false);
                currentBall.restitution = 0.4;
                canDrop = false;
                currentBall = null;
                setTimeout(Game.spawnNext, 800);
            }
        },

        exitBuffMode: () => {
            document.body.classList.remove('destroy-mode');
            const btn = document.getElementById('buff-btn');
            btn.classList.remove('active-mode'); 
            document.getElementById('buff-icon').innerText = "üî®";
        },

        handleCollisions: (event) => {
            const pairs = event.pairs;
            pairs.forEach(pair => {
                const { bodyA, bodyB } = pair;

                if(Number.isInteger(bodyA.label) && Number.isInteger(bodyB.label)) {
                    if(bodyA.label === bodyB.label) {
                        const idx = bodyA.label;

                        Matter.World.remove(engine.world, [bodyA, bodyB]);

                        if (idx === BALL_SIZES.length - 1) {
                            score += 1000;
                            Game.playSound('merge');
                        } else {
                            const newIdx = idx + 1;
                            const midX = (bodyA.position.x + bodyB.position.x)/2;
                            const midY = (bodyA.position.y + bodyB.position.y)/2;

                            const skin = SKINS_DB[currentSkin];
                            const level = skin.levels[newIdx];
                            const size = BALL_SIZES[newIdx];

                            const newBody = Matter.Bodies.circle(midX, midY, size, {
                                label: newIdx,
                                restitution: 0.3,
                                render: { fillStyle: level.color }
                            });
                            Matter.World.add(engine.world, newBody);

                            score += level.score;
                            Game.playSound('merge');
                        }

                        Game.updateUI();
                    }
                }
            });
        },

        activateBuff: (e) => {
            // –°—á–∏—Ç–∞–µ–º —Å–∫–æ–ª—å–∫–æ –≤—Å–µ–≥–æ –Ω–∞–∫–æ–ø–∏–ª–∏
            const totalHammersEarned = Math.floor(score / SCORE_PER_HAMMER);
            const hammersAvailable = totalHammersEarned - hammersUsed;

            // –ï—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω —Ä–µ–∂–∏–º - –≤—ã–∫–ª—é—á–∞–µ–º (–æ—Ç–º–µ–Ω–∞)
            if(isBuffActive) {
                isBuffActive = false;
                Game.exitBuffMode();
                return;
            }

            // –ï—Å–ª–∏ –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∏ —Ä–µ–∂–∏–º –≤—ã–∫–ª—é—á–µ–Ω - –≤–∫–ª—é—á–∞–µ–º
            if(hammersAvailable > 0) {
                isBuffActive = true;
                document.body.classList.add('destroy-mode');
                const btn = document.getElementById('buff-btn');
                btn.classList.add('active-mode'); 
                document.getElementById('buff-icon').innerText = "‚ùå";
            }
        },

        updateUI: () => {
            document.getElementById('score-val').innerText = score;

            // –õ–û–ì–ò–ö–ê –ù–ê–ö–û–ü–õ–ï–ù–ò–Ø
            const totalHammersEarned = Math.floor(score / SCORE_PER_HAMMER);
            const hammersAvailable = totalHammersEarned - hammersUsed;
            const progress = score % SCORE_PER_HAMMER;
            const percentage = (progress / SCORE_PER_HAMMER) * 100;

            // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –±–∞—Ä
            document.getElementById('buff-progress').style.height = percentage + '%';

            const btn = document.getElementById('buff-btn');
            const badge = document.getElementById('buff-count-badge');

            // –û–±–Ω–æ–≤–ª—è–µ–º –±–µ–π–¥–∂ —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º
            if(hammersAvailable > 0) {
                badge.innerText = hammersAvailable;
                badge.classList.add('visible');
                if(!isBuffActive) btn.classList.add('ready');
            } else {
                badge.classList.remove('visible');
                btn.classList.remove('ready');
            }
        },

        renderCustomSkins: () => {
            const ctx = render.context;
            const bodies = Matter.Composite.allBodies(engine.world);
            const skin = SKINS_DB[currentSkin];

            ctx.font = "bold 20px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            bodies.forEach(body => {
                if(Number.isInteger(body.label)) {
                    const lvlData = skin.levels[body.label];
                    const size = BALL_SIZES[body.label];

                    if(skin.type === 'image' && lvlData.file) {
                        const img = new Image();
                        img.src = skin.path + lvlData.file;
                        if(img.complete) {
                            ctx.drawImage(img, body.position.x - size, body.position.y - size, size*2, size*2);
                        } else {
                            ctx.font = `${size*1.2}px Arial`;
                            ctx.fillText(lvlData.label, body.position.x, body.position.y);
                        }
                    } else {
                        ctx.font = `${size*1.2}px Arial`;
                        ctx.fillText(lvlData.label, body.position.x, body.position.y + (size*0.1));
                    }
                }
            });

            ctx.beginPath();
            ctx.moveTo(0, 150);
            ctx.lineTo(W, 150);
            ctx.strokeStyle = 'rgba(255,50,50,0.4)';
            ctx.setLineDash([10, 15]);
            ctx.stroke();

            Game.checkGameOver(bodies);
        },

        checkGameOver: (bodies) => {
            if(!gameActive) return;
            for(let b of bodies) {
                if(!b.isStatic && b.position.y < 150 && Math.abs(b.velocity.y) < 0.1) {
                    Menu.showGameOver();
                    break;
                }
            }
        },

        playSound: (type) => {
            if(SOUNDS_CFG[type]) {
               const audio = new Audio(SOUNDS_CFG[type]);
               audio.play().catch(e=>{});
            } else {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.value = 300 + (Math.random()*200);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            }
        }
    };

    document.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
</script>
</body>
</html>