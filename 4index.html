<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Merge Game 2.5</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* --- –°–¢–ò–õ–ò –ò–ù–¢–ï–†–§–ï–ô–°–ê --- */
        body { margin: 0; padding: 0; overflow: hidden; background: #121212; font-family: 'Segoe UI', sans-serif; touch-action: none; color: white; -webkit-tap-highlight-color: transparent; }
        #game-container { position: relative; width: 100%; height: 100vh; }

        .layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .interactive { pointer-events: auto; }

        /* HUD */
        #hud {
            display: flex; justify-content: space-between; align-items: flex-start;
            padding: 15px; box-sizing: border-box; z-index: 5;
            position: absolute; top: 0; left: 0; width: 100%;
            pointer-events: none; 
        }
        #hud > * { pointer-events: auto; }

        /* –°—á–µ—Ç */
        .score-box {
            background: rgba(0,0,0,0.6);
            padding: 10px 15px;
            border-radius: 15px;
            display: flex; flex-direction: column; gap: 5px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .score-val { font-size: 22px; font-weight: bold; color: #fff; }

        .next-box {
            display: flex; align-items: center; gap: 8px;
            font-size: 13px; color: #ccc;
            border-top: 1px solid rgba(255,255,255,0.2);
            padding-top: 5px; margin-top: 2px;
        }
        .next-circle {
            width: 20px; height: 20px; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 14px; background: #333;
        }

        /* –ö–û–ù–¢–ï–ô–ù–ï–† –ë–ê–§–§–û–í (–°–ø—Ä–∞–≤–∞) */
        #buffs-wrapper {
            display: flex; flex-direction: column; gap: 15px;
            align-items: flex-end;
        }

        .buff-item {
            display: flex; flex-direction: column; align-items: center;
        }

        .buff-btn {
            width: 50px; height: 50px;
            border-radius: 50%;
            background: #333; border: 2px solid #555;
            display: flex; justify-content: center; align-items: center;
            font-size: 22px; cursor: pointer;
            position: relative; transition: transform 0.1s;
            overflow: visible; user-select: none;
        }

        .buff-badge {
            position: absolute; top: -5px; right: -5px;
            background: red; color: white;
            font-size: 11px; font-weight: bold;
            width: 18px; height: 18px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            border: 2px solid #121212; z-index: 10;
            opacity: 0; transition: opacity 0.3s;
        }
        .buff-badge.visible { opacity: 1; }

        /* –ö—Ä—É–≥–æ–≤–æ–π –ø—Ä–æ–≥—Ä–µ—Å—Å —á–µ—Ä–µ–∑ CSS conic-gradient (–ø—Ä–æ—â–µ –¥–ª—è –¥–≤—É—Ö –∫–Ω–æ–ø–æ–∫) */
        .buff-btn::before {
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            border-radius: 50%; z-index: 1; opacity: 0.3; transition: 0.3s;
        }

        /* –°—Ç–∏–ª–∏ —Å–æ—Å—Ç–æ—è–Ω–∏–π */
        .buff-btn.ready { border-color: #fff; box-shadow: 0 0 10px rgba(255, 255, 255, 0.3); }

        /* –ê–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º */
        .buff-btn.active-hammer { background: #ffcc00; color: black; animation: pulse 1s infinite; border-color: #ffcc00; }
        .buff-btn.active-bomb { background: #ff4444; color: white; animation: pulse 1s infinite; border-color: #ff4444; }

        .cost-label { font-size: 10px; margin-top: 3px; opacity: 0.7; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        /* –ú–ï–ù–Æ */
        .menu-overlay {
            background: rgba(0,0,0,0.95); z-index: 20; display: flex; flex-direction: column;
            align-items: center; justify-content: center; backdrop-filter: blur(5px);
        }
        .hidden { display: none !important; }

        h1 { margin-bottom: 30px; font-size: 40px; background: -webkit-linear-gradient(#eee, #333); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }

        .menu-btn {
            background: #333; color: white; border: 1px solid #555;
            width: 200px; padding: 15px; margin: 10px; border-radius: 12px;
            font-size: 18px; cursor: pointer; transition: 0.2s;
        }
        .menu-btn:active { transform: scale(0.95); }
        .btn-primary { background: #0088cc; border: none; font-weight: bold; }

        .scroll-list { width: 80%; max-height: 50%; overflow-y: auto; background: #222; border-radius: 10px; padding: 10px; margin-bottom: 20px; }
        .list-item { display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 1px solid #333; cursor: pointer; }
        .list-item.selected { background: #004466; }

        /* –ö—É—Ä—Å–æ—Ä—ã –¥–ª—è —Ä–µ–∂–∏–º–æ–≤ */
        .mode-hammer { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><text y="20" font-size="20">üî®</text></svg>'), auto !important; }
        .mode-bomb { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><text y="20" font-size="20">üí£</text></svg>'), auto !important; }

        .mode-active #game-container { border: 4px solid; box-sizing: border-box; }
        .mode-hammer #game-container { border-color: #ffcc00; }
        .mode-bomb #game-container { border-color: #ff4444; }
    </style>
</head>
<body>

<div id="game-container">
    <!-- –ú–ï–ù–Æ -->
    <div id="main-menu" class="layer interactive menu-overlay">
        <h1>MEME DROP</h1>
        <button class="menu-btn btn-primary" onclick="Game.start()">–ò–ì–†–ê–¢–¨</button>
        <button class="menu-btn" onclick="Menu.showSkins()">–°–ö–ò–ù–´</button>
        <button class="menu-btn" onclick="Menu.showLeaderboard()">–†–ï–ö–û–†–î–´</button>
    </div>

    <div id="skins-menu" class="layer interactive menu-overlay hidden">
        <h2>–í–´–ë–û–† –°–ö–ò–ù–ê</h2>
        <div class="scroll-list" id="skins-list"></div>
        <button class="menu-btn" onclick="Menu.backToMain()">–ù–ê–ó–ê–î</button>
    </div>

    <div id="leaderboard-menu" class="layer interactive menu-overlay hidden">
        <h2>–¢–û–ü –ò–ì–†–û–ö–û–í</h2>
        <div class="scroll-list" id="leaderboard-list"></div>
        <button class="menu-btn" onclick="Menu.backToMain()">–ù–ê–ó–ê–î</button>
    </div>

    <div id="game-over-menu" class="layer interactive menu-overlay hidden">
        <h1 style="-webkit-text-fill-color: red;">GAME OVER</h1>
        <p>–°—á–µ—Ç: <span id="final-score">0</span></p>
        <button class="menu-btn btn-primary" onclick="location.reload()">–ó–ê–ù–û–í–û</button>
        <button class="menu-btn" onclick="Menu.backToMain()">–ú–ï–ù–Æ</button>
    </div>

    <!-- HUD -->
    <div id="hud" class="layer hidden">
        <div class="score-box">
            <div class="score-val">üèÜ <span id="score-val">0</span></div>
            <div class="next-box">
                <span>–î–∞–ª–µ–µ:</span>
                <div class="next-circle" id="next-ball-icon">?</div>
            </div>
        </div>

        <div id="buffs-wrapper">
            <!-- –ú–û–õ–û–¢–û–ö (2500) -->
            <div class="buff-item">
                <div id="btn-hammer" class="buff-btn" onclick="Game.toggleBuff('hammer')" ontouchstart="event.stopPropagation()">
                    <span id="icon-hammer">üî®</span>
                    <div id="badge-hammer" class="buff-badge">0</div>
                </div>
                <div class="cost-label">2500</div>
            </div>

            <!-- –ë–û–ú–ë–ê (4000) -->
            <div class="buff-item">
                <div id="btn-bomb" class="buff-btn" onclick="Game.toggleBuff('bomb')" ontouchstart="event.stopPropagation()">
                    <span id="icon-bomb">üí£</span>
                    <div id="badge-bomb" class="buff-badge">0</div>
                </div>
                <div class="cost-label">4000</div>
            </div>
        </div>
    </div>
</div>

<script>
    const SOUNDS_CFG = { merge: null, drop: null, gameover: null };

    const SKINS_DB = {
        'memes': {
            name: '–ú–µ–º—ã',
            levels: [
                { color: '#FFD700', label: 'ü§°', score: 2 },
                { color: '#FFA500', label: 'üí©', score: 4 },
                { color: '#FF4500', label: 'üêπ', score: 8 },
                { color: '#DC143C', label: 'ü™ô', score: 16 },
                { color: '#C71585', label: 'üí∏', score: 32 },
                { color: '#8A2BE2', label: 'üöô', score: 64 },
                { color: '#4169E1', label: 'üíé', score: 128 },
                { color: '#00BFFF', label: 'üëë', score: 256 },
                { color: '#00FA9A', label: 'üóø', score: 512 }
            ],
            type: 'emoji'
        },
        'fruits': {
            name: '–§—Ä—É–∫—Ç—ã',
            levels: [
                { color: '#F00', label: 'üçí', score: 2 },
                { color: '#F00', label: 'üçì', score: 4 },
                { color: '#800080', label: 'üçá', score: 8 },
                { color: '#FFA500', label: 'üçä', score: 16 },
                { color: '#FFA500', label: 'ü•≠', score: 32 },
                { color: '#FF0000', label: 'üçé', score: 64 },
                { color: '#FFFF00', label: 'üçê', score: 128 },
                { color: '#FFC0CB', label: 'üçë', score: 256 },
                { color: '#008000', label: 'üçâ', score: 512 }
            ],
            type: 'emoji'
        }
    };

    // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –≤—Å–ø–ª—ã—Ç–∏—è (–¥–ª—è –∫–Ω–æ–ø–æ–∫)
    function stopPropagation(e) { e.stopPropagation(); }
    document.getElementById('hud').addEventListener('mousedown', stopPropagation);
    document.getElementById('hud').addEventListener('touchstart', stopPropagation);
    document.querySelectorAll('.menu-overlay').forEach(el => {
        el.addEventListener('mousedown', stopPropagation);
        el.addEventListener('touchstart', stopPropagation);
    });

    // –°–∏—Å—Ç–µ–º–∞ —á–∞—Å—Ç–∏—Ü
    const Particles = {
        list: [],
        spawn: (x, y, color) => {
            for(let i=0; i<12; i++) {
                Particles.list.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0,
                    color: color,
                    size: Math.random() * 5 + 2
                });
            }
        },
        update: () => {
            for(let i = Particles.list.length - 1; i >= 0; i--) {
                let p = Particles.list[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                if(p.life <= 0) Particles.list.splice(i, 1);
            }
        },
        draw: (ctx) => {
            Particles.list.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
        }
    };

    let currentSkin = 'memes';
    let engine, render, runner;
    let ground, leftW, rightW;
    let score = 0;

    // –ë–ê–§–§–´
    const COST_HAMMER = 2500;
    const COST_BOMB = 4000;
    let hammersUsed = 0;
    let bombsUsed = 0;
    let activeBuff = null; // 'hammer' | 'bomb' | null

    let gameActive = false;
    let currentBall = null;
    let canDrop = true;
    let upcomingBallIndex = 0; 
    let W = window.innerWidth;
    let H = window.innerHeight;
    const BALL_SIZES = [18, 27, 36, 45, 54, 63, 72, 81, 90];
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    const Menu = {
        hideAll: () => document.querySelectorAll('.menu-overlay').forEach(el => el.classList.add('hidden')),
        backToMain: () => { Menu.hideAll(); document.getElementById('main-menu').classList.remove('hidden'); },
        showSkins: () => {
            Menu.hideAll();
            document.getElementById('skins-menu').classList.remove('hidden');
            const list = document.getElementById('skins-list');
            list.innerHTML = '';
            for (let key in SKINS_DB) {
                const skin = SKINS_DB[key];
                const div = document.createElement('div');
                div.className = `list-item ${currentSkin === key ? 'selected' : ''}`;
                div.innerHTML = `<span>${skin.name}</span> <span>${skin.levels[0].label}</span>`;
                div.onclick = () => { currentSkin = key; localStorage.setItem('selectedSkin', key); Menu.showSkins(); };
                list.appendChild(div);
            }
        },
        showLeaderboard: () => {
            Menu.hideAll();
            document.getElementById('leaderboard-menu').classList.remove('hidden');
            const list = document.getElementById('leaderboard-list');
            let records = JSON.parse(localStorage.getItem('leaderboard')) || [];
            records.sort((a,b) => b.score - a.score);
            list.innerHTML = '';
            if(records.length === 0) list.innerHTML = '<div style="padding:10px;text-align:center">–ù–µ—Ç –∑–∞–ø–∏—Å–µ–π</div>';
            records.slice(0, 10).forEach((rec, i) => {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.innerHTML = `<div><span class="rank">#${i+1}</span> ${rec.name}</div> <div>${rec.score}</div>`;
                list.appendChild(div);
            });
        },
        showGameOver: () => {
            gameActive = false;
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-menu').classList.remove('hidden');
            let records = JSON.parse(localStorage.getItem('leaderboard')) || [];
            records.push({name: "–ò–≥—Ä–æ–∫", score: score, date: new Date()});
            localStorage.setItem('leaderboard', JSON.stringify(records));
        }
    };

    const Game = {
        start: () => {
            Menu.hideAll();
            document.getElementById('hud').classList.remove('hidden');
            const savedSkin = localStorage.getItem('selectedSkin');
            if(savedSkin && SKINS_DB[savedSkin]) currentSkin = savedSkin;

            Game.initPhysics();
            score = 0;
            hammersUsed = 0;
            bombsUsed = 0;
            Game.deactivateBuffs();
            Particles.list = [];

            upcomingBallIndex = Math.floor(Math.random() * 3); 
            Game.updateUI();
            gameActive = true;
            Game.spawnNext();
        },

        initPhysics: () => {
            if(engine) {
                Matter.World.clear(engine.world);
                Matter.Engine.clear(engine);
                if(render) { render.canvas.remove(); render.canvas = null; render.context = null; }
                if(runner) Matter.Runner.stop(runner);
            }
            W = window.innerWidth;
            H = window.innerHeight;

            engine = Matter.Engine.create();
            render = Matter.Render.create({
                element: document.getElementById('game-container'),
                engine: engine,
                options: { width: W, height: H, wireframes: false, background: 'transparent' }
            });

            const wallOpts = { isStatic: true, render: { fillStyle: '#333' } };
            ground = Matter.Bodies.rectangle(W/2, H + 50, W, 100, wallOpts); 
            leftW = Matter.Bodies.rectangle(0, H/2, 20, H, wallOpts);
            rightW = Matter.Bodies.rectangle(W, H/2, 20, H, wallOpts);
            Matter.World.add(engine.world, [ground, leftW, rightW]);

            Matter.Events.on(render, 'afterRender', () => {
                Game.renderCustomSkins();
                Particles.update();
                Particles.draw(render.context);
            });
            Matter.Events.on(engine, 'collisionStart', Game.handleCollisions);

            runner = Matter.Runner.create();
            Matter.Runner.run(runner, engine);
            Matter.Render.run(render);

            window.addEventListener('mousedown', Game.handleInput);
            window.addEventListener('touchstart', Game.handleInput, { passive: false });
            window.addEventListener('mousemove', Game.moveBall);
            window.addEventListener('touchmove', Game.moveBall, { passive: false });
            window.addEventListener('resize', Game.handleResize);
        },

        handleResize: () => {
            W = window.innerWidth;
            H = window.innerHeight;
            render.canvas.width = W;
            render.canvas.height = H;
            Matter.Body.setPosition(ground, { x: W/2, y: H + 50 });
            Matter.Body.setPosition(rightW, { x: W, y: H/2 });
        },

        spawnNext: () => {
            if(!gameActive) return;
            const indexToSpawn = upcomingBallIndex;
            upcomingBallIndex = Math.floor(Math.random() * 3);

            const skin = SKINS_DB[currentSkin];
            const nextLevelData = skin.levels[upcomingBallIndex];
            const nextIconEl = document.getElementById('next-ball-icon');
            nextIconEl.innerText = nextLevelData.label;
            nextIconEl.style.backgroundColor = nextLevelData.color;

            const size = BALL_SIZES[indexToSpawn];
            const levelData = skin.levels[indexToSpawn];

            currentBall = Matter.Bodies.circle(W/2, 60, size, {
                isStatic: true, label: indexToSpawn, render: { fillStyle: levelData.color }
            });
            Matter.World.add(engine.world, currentBall);
            canDrop = true;
        },

        moveBall: (e) => {
            // –§–ò–ö–°: –ï—Å–ª–∏ –ø–∞–ª–µ—Ü –Ω–∞–¥ HUD –∏–ª–∏ –∫–Ω–æ–ø–∫–æ–π, –Ω–µ –¥–≤–∏–≥–∞–µ–º —à–∞—Ä
            if(e.target.closest('#hud') || e.target.closest('.interactive')) return;

            if(canDrop && currentBall && !activeBuff) {
                let x = (e.touches ? e.touches[0].clientX : e.clientX);
                x = Math.max(30, Math.min(x, W - 30));
                Matter.Body.setPosition(currentBall, { x: x, y: 60 });
            }
        },

        handleInput: (e) => {
            if(!gameActive) return;
            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–ª–∏–∫–∏ –ø–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É
            if(e.target.closest('#hud') || e.target.closest('.menu-overlay')) return;

            // –û–ë–†–ê–ë–û–¢–ö–ê –ë–ê–§–§–û–í
            if(activeBuff) {
                const x = (e.touches ? e.touches[0].clientX : e.clientX);
                const y = (e.touches ? e.touches[0].clientY : e.clientY);
                const bodies = Matter.Composite.allBodies(engine.world);
                // –ò—â–µ–º —Ç–µ–ª–æ –ø–æ–¥ –∫–ª–∏–∫–æ–º (–∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏–∫—É - —Ç.–µ. —à–∞—Ä –≤ —Ä—É–∫–µ)
                const clickedBody = bodies.find(b => Matter.Bounds.contains(b.bounds, {x:x, y:y}) && !b.isStatic && Number.isInteger(b.label));

                if(clickedBody) {
                    const skin = SKINS_DB[currentSkin];

                    if(activeBuff === 'hammer') {
                        // –≠—Ñ—Ñ–µ–∫—Ç
                        Particles.spawn(clickedBody.position.x, clickedBody.position.y, clickedBody.render.fillStyle);
                        Matter.World.remove(engine.world, clickedBody);
                        hammersUsed++;
                    } 
                    else if(activeBuff === 'bomb') {
                        const targetType = clickedBody.label;
                        const targets = bodies.filter(b => b.label === targetType && !b.isStatic);

                        targets.forEach(b => {
                            Particles.spawn(b.position.x, b.position.y, b.render.fillStyle);
                            Matter.World.remove(engine.world, b);
                        });
                        bombsUsed++;
                    }

                    Game.deactivateBuffs();
                    Game.updateUI();
                }
                return;
            }

            // –ë–†–û–°–û–ö
            if(canDrop && currentBall) {
                let x = (e.touches ? e.touches[0].clientX : e.clientX);
                x = Math.max(30, Math.min(x, W - 30));
                Matter.Body.setPosition(currentBall, { x: x, y: 60 });
                Matter.Body.setStatic(currentBall, false);
                currentBall.restitution = 0.4;
                canDrop = false;
                currentBall = null;
                setTimeout(Game.spawnNext, 800);
            }
        },

        toggleBuff: (type) => {
            if(activeBuff === type) {
                Game.deactivateBuffs(); // –û—Ç–º–µ–Ω–∞
            } else {
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
                const hammerCount = Math.floor(score / COST_HAMMER) - hammersUsed;
                const bombCount = Math.floor(score / COST_BOMB) - bombsUsed;

                if(type === 'hammer' && hammerCount > 0) {
                    Game.setActiveMode('hammer');
                } else if(type === 'bomb' && bombCount > 0) {
                    Game.setActiveMode('bomb');
                }
            }
        },

        setActiveMode: (mode) => {
            activeBuff = mode;
            document.body.className = ''; // reset
            document.body.classList.add('mode-active');

            const btnHammer = document.getElementById('btn-hammer');
            const btnBomb = document.getElementById('btn-bomb');
            btnHammer.classList.remove('active-hammer');
            btnBomb.classList.remove('active-bomb');

            if(mode === 'hammer') {
                document.body.classList.add('mode-hammer');
                btnHammer.classList.add('active-hammer');
            } else if(mode === 'bomb') {
                document.body.classList.add('mode-bomb');
                btnBomb.classList.add('active-bomb');
            }
        },

        deactivateBuffs: () => {
            activeBuff = null;
            document.body.className = '';
            document.getElementById('btn-hammer').classList.remove('active-hammer');
            document.getElementById('btn-bomb').classList.remove('active-bomb');
        },

        handleCollisions: (event) => {
            const pairs = event.pairs;
            pairs.forEach(pair => {
                const { bodyA, bodyB } = pair;
                if(Number.isInteger(bodyA.label) && Number.isInteger(bodyB.label)) {
                    if(bodyA.label === bodyB.label) {
                        const idx = bodyA.label;
                        const midX = (bodyA.position.x + bodyB.position.x)/2;
                        const midY = (bodyA.position.y + bodyB.position.y)/2;

                        // –≠—Ñ—Ñ–µ–∫—Ç —Å–ª–∏—è–Ω–∏—è
                        Particles.spawn(midX, midY, bodyA.render.fillStyle);

                        Matter.World.remove(engine.world, [bodyA, bodyB]);

                        if (idx === BALL_SIZES.length - 1) {
                            score += 1000;
                            Game.playSound('merge');
                        } else {
                            const newIdx = idx + 1;
                            const skin = SKINS_DB[currentSkin];
                            const level = skin.levels[newIdx];
                            const size = BALL_SIZES[newIdx];

                            const newBody = Matter.Bodies.circle(midX, midY, size, {
                                label: newIdx, restitution: 0.3, render: { fillStyle: level.color }
                            });
                            Matter.World.add(engine.world, newBody);
                            score += level.score;
                            Game.playSound('merge');
                        }
                        Game.updateUI();
                    }
                }
            });
        },

        updateUI: () => {
            document.getElementById('score-val').innerText = score;

            const hammerCount = Math.floor(score / COST_HAMMER) - hammersUsed;
            const bombCount = Math.floor(score / COST_BOMB) - bombsUsed;

            // Hammer UI
            const hBadge = document.getElementById('badge-hammer');
            const hBtn = document.getElementById('btn-hammer');
            if(hammerCount > 0) {
                hBadge.innerText = hammerCount;
                hBadge.classList.add('visible');
                hBtn.classList.add('ready');
                // –ü—Ä–æ–≥—Ä–µ—Å—Å –±–∞—Ä –¥–ª—è —Ö–∞–º–º–µ—Ä–∞ (—Ä–∞–¥–∏–∞–ª—å–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç)
                const hProg = (score % COST_HAMMER) / COST_HAMMER * 100;
                hBtn.style.background = `conic-gradient(#ffcc00 ${hProg}%, #333 0)`;
            } else {
                hBadge.classList.remove('visible');
                hBtn.classList.remove('ready');
                const hProg = (score % COST_HAMMER) / COST_HAMMER * 100;
                hBtn.style.background = `conic-gradient(rgba(255,204,0,0.3) ${hProg}%, #333 0)`;
            }

            // Bomb UI
            const bBadge = document.getElementById('badge-bomb');
            const bBtn = document.getElementById('btn-bomb');
            if(bombCount > 0) {
                bBadge.innerText = bombCount;
                bBadge.classList.add('visible');
                bBtn.classList.add('ready');
                const bProg = (score % COST_BOMB) / COST_BOMB * 100;
                bBtn.style.background = `conic-gradient(#ff4444 ${bProg}%, #333 0)`;
            } else {
                bBadge.classList.remove('visible');
                bBtn.classList.remove('ready');
                const bProg = (score % COST_BOMB) / COST_BOMB * 100;
                bBtn.style.background = `conic-gradient(rgba(255,68,68,0.3) ${bProg}%, #333 0)`;
            }
        },

        renderCustomSkins: () => {
            const ctx = render.context;
            const bodies = Matter.Composite.allBodies(engine.world);
            const skin = SKINS_DB[currentSkin];

            ctx.font = "bold 20px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            bodies.forEach(body => {
                if(Number.isInteger(body.label)) {
                    const lvlData = skin.levels[body.label];
                    const size = BALL_SIZES[body.label];

                    if(skin.type === 'image' && lvlData.file) {
                        const img = new Image(); img.src = skin.path + lvlData.file;
                        if(img.complete) ctx.drawImage(img, body.position.x - size, body.position.y - size, size*2, size*2);
                        else { ctx.font = `${size*1.2}px Arial`; ctx.fillText(lvlData.label, body.position.x, body.position.y); }
                    } else {
                        ctx.font = `${size*1.2}px Arial`;
                        ctx.fillText(lvlData.label, body.position.x, body.position.y + (size*0.1));
                    }
                }
            });

            // Dead Line
            ctx.beginPath();
            ctx.moveTo(0, 150); ctx.lineTo(W, 150);
            ctx.strokeStyle = 'rgba(255,50,50,0.4)';
            ctx.setLineDash([10, 15]); ctx.stroke();

            Game.checkGameOver(bodies);
        },

        checkGameOver: (bodies) => {
            if(!gameActive) return;
            for(let b of bodies) {
                if(!b.isStatic && b.position.y < 150 && Math.abs(b.velocity.y) < 0.1) {
                    Menu.showGameOver();
                    break;
                }
            }
        },

        playSound: (type) => {
            if(SOUNDS_CFG[type]) { new Audio(SOUNDS_CFG[type]).play().catch(e=>{}); } 
            else {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.frequency.value = 300 + (Math.random()*200);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            }
        }
    };

    document.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
</script>
</body>
</html>