<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ball Escape Challenge</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: white;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        canvas {
            box-shadow: 0 0 50px rgba(255, 50, 50, 0.2);
            border-radius: 50%;
        }

        #ui {
            position: absolute;
            bottom: 50px;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        #timer {
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #fff;
        }

        #status {
            font-size: 18px;
            color: #aaa;
            margin-top: 10px;
        }

        #restart-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            font-size: 24px;
            background: white;
            color: black;
            border: none;
            cursor: pointer;
            border-radius: 30px;
            display: none;
            pointer-events: auto;
            z-index: 20;
            font-family: inherit;
            font-weight: bold;
        }

        #restart-btn:hover {
            background: #ddd;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="timer">100.00</div>
        <div id="status">Мяч должен сбежать!</div>
    </div>

    <button id="restart-btn" onclick="Game.restart()">ПОВТОРИТЬ</button>
    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Настройки игры
    const CONFIG = {
        ringCount: 16,        // Количество колец
        ringGap: 25,          // Расстояние между кольцами
        startRadius: 50,      // Радиус первого кольца
        ballRadius: 8,        // Размер мяча
        rotationSpeed: 0.015, // Скорость вращения колец
        gravity: 0.15,        // Сила гравитации
        bounce: 1,          // Упругость (1 = вечный прыжок, 0.9 = теряет энергию)
        gapSize: Math.PI / 4, // Размер дырки в кольце (в радианах)
        timeLimit: 100        // Секунды
    };

    let width, height, centerX, centerY;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        // Делаем квадратный канвас, чтобы круги были ровными
        const size = Math.min(width, height) * 0.95;
        canvas.width = size;
        canvas.height = size;
        centerX = size / 2;
        centerY = size / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    class Ball {
        constructor() {
            this.reset();
        }

        reset() {
            this.x = 0;
            this.y = 0;
            this.vx = 2; // Начальный толчок
            this.vy = 0;
            this.escaped = false;
        }

        update() {
            if (this.escaped) return;

            // Гравитация
            this.vy += CONFIG.gravity;

            // Движение
            this.x += this.vx;
            this.y += this.vy;

            // Расстояние от центра
            this.dist = Math.sqrt(this.x * this.x + this.y * this.y);

            // Угол мяча (-PI до PI)
            this.angle = Math.atan2(this.y, this.x); 
            // Нормализуем угол к 0...2PI для удобства
            if (this.angle < 0) this.angle += Math.PI * 2;
        }

        draw() {
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.beginPath();
            ctx.arc(this.x, this.y, CONFIG.ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#00ffff'; // Голубой неон (Cyan)
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00ffff';
            ctx.fill();
            ctx.restore();
        }
    }

    class Ring {
        constructor(index) {
            this.index = index;
            this.radius = CONFIG.startRadius + (index * CONFIG.ringGap);
            this.active = true;

            // Смещение отверстия для спирального эффекта
            this.angleOffset = index * 0.5; 

            // Цвет (Градиент от белого к красному)
            const hue = 0; // Красный
            const light = 100 - (index * (50 / CONFIG.ringCount)); // От 100% до 50% яркости
            this.color = `hsl(${hue}, 100%, ${light}%)`;
        }

        update() {
            // Вращение кольца
            this.angleOffset += CONFIG.rotationSpeed;
            // Нормализация угла
            if (this.angleOffset > Math.PI * 2) this.angleOffset -= Math.PI * 2;
        }

        checkCollision(ball) {
            if (!this.active) return;

            // Проверяем, касается ли мяч этого кольца
            // Мы проверяем "внутреннюю" границу кольца для отскока
            const distToRing = this.radius - ball.dist;

            // Если мяч пересек линию кольца (с учетом его радиуса)
            if (distToRing < CONFIG.ballRadius && distToRing > -CONFIG.ballRadius * 2) {

                // Проверяем, попал ли он в дырку
                // Вычисляем угол дырки
                let gapStart = this.angleOffset;
                let gapEnd = this.angleOffset + CONFIG.gapSize;

                // Нормализуем углы мяча и дырки для корректного сравнения
                let ballA = ball.angle;

                // Проверка попадания в интервал угла (с учетом перехода через 0/360)
                let inGap = false;

                // Сложная логика нормализации углов, чтобы понять, внутри ли мы сектора
                const checkAngle = (a, start, end) => {
                    // Приводим все к 0..2PI
                    start = start % (Math.PI*2);
                    end = end % (Math.PI*2);
                    if (start < 0) start += Math.PI*2;
                    if (end < 0) end += Math.PI*2;

                    if (start < end) {
                        return a >= start && a <= end;
                    } else {
                        // Переход через ноль
                        return a >= start || a <= end;
                    }
                };

                inGap = checkAngle(ballA, gapStart, gapEnd);

                if (inGap) {
                    // ПРОШЕЛ СКВОЗЬ!
                    // Отключаем кольцо, только если мяч полностью вышел за его радиус
                    if (ball.dist > this.radius + CONFIG.ballRadius) {
                        this.active = false;
                        // Звук прохождения (опционально)
                    }
                } else {
                    // ОТСКОК (БЬЕТСЯ ОБ СТЕНУ)
                    // Вектор нормали (от центра к мячу)
                    const nx = ball.x / ball.dist;
                    const ny = ball.y / ball.dist;

                    // Отражаем вектор скорости
                    // V_new = V - 2(V . N)N
                    const dot = ball.vx * nx + ball.vy * ny;

                    // Только если летит "наружу"
                    if (dot > 0) {
                        ball.vx = (ball.vx - 2 * dot * nx) * CONFIG.bounce;
                        ball.vy = (ball.vy - 2 * dot * ny) * CONFIG.bounce;

                        // Выталкиваем мяч чуть внутрь, чтобы не застрял
                        const overlap = CONFIG.ballRadius - distToRing;
                        ball.x -= nx * overlap; 
                        ball.y -= ny * overlap;
                    }
                }
            } else if (ball.dist > this.radius + CONFIG.ballRadius) {
                // Если мы как-то оказались снаружи (например, пролетели), выключаем кольцо
                this.active = false;
            }
        }

        draw() {
            if (!this.active) return;

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(this.angleOffset);

            ctx.beginPath();
            // Рисуем дугу (кольцо минус дырка)
            // Полный круг это 0 до 2PI. Дырка от 0 до gapSize. Значит рисуем от gapSize до 2PI
            ctx.arc(0, 0, this.radius, CONFIG.gapSize, Math.PI * 2);

            ctx.strokeStyle = this.color;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            // Эффект свечения
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;

            ctx.stroke();
            ctx.restore();
        }
    }

    const Game = {
        rings: [],
        ball: null,
        startTime: 0,
        running: false,
        loopId: null,

        init() {
            this.ball = new Ball();
            this.createRings();
            this.startTime = Date.now();
            this.running = true;
            document.getElementById('restart-btn').style.display = 'none';
            this.loop();
        },

        createRings() {
            this.rings = [];
            for (let i = 0; i < CONFIG.ringCount; i++) {
                this.rings.push(new Ring(i));
            }
        },

        restart() {
            cancelAnimationFrame(this.loopId);
            this.init();
        },

        checkWin() {
            // Если все кольца неактивны
            const activeRings = this.rings.filter(r => r.active);
            if (activeRings.length === 0) {
                this.running = false;
                document.getElementById('status').innerText = "ПОБЕДА! Мяч свободен.";
                document.getElementById('status').style.color = "#0f0";
                document.getElementById('restart-btn').style.display = 'block';
                return true;
            }
            return false;
        },

        updateTimer() {
            if (!this.running) return;
            const elapsed = (Date.now() - this.startTime) / 1000;
            const remaining = Math.max(0, CONFIG.timeLimit - elapsed);

            document.getElementById('timer').innerText = remaining.toFixed(2);

            if (remaining <= 0) {
                this.running = false;
                document.getElementById('status').innerText = "ВРЕМЯ ВЫШЛО";
                document.getElementById('status').style.color = "red";
                document.getElementById('restart-btn').style.display = 'block';
            }
        },

        loop() {
            // Очистка
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (Game.running) {
                Game.ball.update();
                Game.rings.forEach(ring => {
                    ring.update();
                    ring.checkCollision(Game.ball);
                });
                Game.updateTimer();
                Game.checkWin();

                // Проверка вылета за пределы экрана (на всякий случай)
                if (Game.ball.dist > Math.max(width, height)) {
                   // Авто-победа если улетел далеко
                   Game.rings.forEach(r => r.active = false); 
                }
            }

            // Отрисовка (сначала внешние кольца для красоты наложения, или внутренние?)
            // Рисуем кольца
            Game.rings.forEach(ring => ring.draw());

            // Рисуем мяч
            Game.ball.draw();

            Game.loopId = requestAnimationFrame(Game.loop);
        }
    };

    // Запуск
    Game.init();

</script>
</body>
</html>