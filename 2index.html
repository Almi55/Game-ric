<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Life Mobile</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;800&display=swap');

        body {
            margin: 0; background-color: #050505; color: #fff; overflow: hidden;
            font-family: 'JetBrains Mono', monospace; touch-action: none;
        }
        canvas { display: block; width: 100vw; height: 100vh; }

        /* --- –ö–ù–û–ü–ö–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø (–í–°–ï–ì–î–ê –í–ò–î–ù–´) --- */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        #btn-gear {
            position: absolute; top: 15px; right: 15px;
            width: 44px; height: 44px;
            background: rgba(0,0,0,0.6); border: 1px solid #444; color: #fff;
            border-radius: 50%; font-size: 22px; cursor: pointer;
            pointer-events: auto; display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(4px); transition: 0.2s;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #btn-gear:active { transform: scale(0.9); background: #fff; color: #000; }

        #fps-meter {
            position: absolute; top: 20px; left: 20px;
            color: #666; font-size: 10px; pointer-events: none;
        }

        /* --- –ú–ï–ù–Æ –ù–ê–°–¢–†–û–ï–ö (–°–ö–†–´–¢–û –ü–û –£–ú–û–õ–ß–ê–ù–ò–Æ) --- */
        #settings-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); backdrop-filter: blur(8px);
            z-index: 20; display: none; /* –°–∫—Ä—ã—Ç–æ */
            justify-content: center; align-items: center;
            pointer-events: auto;
        }

        #settings-panel {
            background: #111; border: 1px solid #333;
            width: 90%; max-width: 360px; max-height: 85vh;
            border-radius: 12px; padding: 20px;
            overflow-y: auto; box-shadow: 0 0 30px rgba(0,0,0,0.8);
            position: relative;
        }

        /* –ö–Ω–æ–ø–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è –≤–Ω—É—Ç—Ä–∏ –º–µ–Ω—é */
        #btn-close {
            position: absolute; top: 15px; right: 15px;
            background: transparent; border: none; color: #666; font-size: 20px;
            cursor: pointer; padding: 5px;
        }

        h2 {
            margin: 0 0 15px 0; color: #fff; font-size: 14px; text-transform: uppercase;
            border-bottom: 1px solid #333; padding-bottom: 8px; letter-spacing: 1px;
        }
        h3 { font-size: 12px; color: #888; margin: 15px 0 8px 0; text-transform: uppercase; }

        /* –ú–∞—Ç—Ä–∏—Ü–∞ */
        .matrix-grid {
            display: grid; grid-template-columns: 20px repeat(4, 1fr); gap: 4px; margin-bottom: 15px;
        }
        .matrix-header { font-size: 10px; text-align: center; color: #888; }
        .matrix-cell input {
            width: 100%; height: 30px; /* –ü–æ–±–æ–ª—å—à–µ –¥–ª—è –ø–∞–ª—å—Ü–µ–≤ */
            background: #1a1a1a; border: 1px solid #333;
            color: #fff; text-align: center; font-size: 12px;
            font-family: inherit; border-radius: 4px;
        }
        .matrix-cell input:focus { border-color: #0f0; outline: none; background: #222; }

        /* –°–ª–∞–π–¥–µ—Ä—ã */
        .control-group { margin-bottom: 12px; }
        label { font-size: 12px; color: #aaa; display: flex; justify-content: space-between; margin-bottom: 5px; }
        .val { color: #0f0; font-weight: bold; }
        input[type=range] {
            width: 100%; height: 6px; background: #333;
            accent-color: #0f0; cursor: pointer; appearance: none; border-radius: 3px;
        }

        /* –ö–Ω–æ–ø–∫–∏ –ø—Ä–µ—Å–µ—Ç–æ–≤ */
        .presets-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        .btn {
            background: #222; color: #fff; border: 1px solid #444;
            padding: 12px; font-family: inherit; font-size: 12px;
            cursor: pointer; text-transform: uppercase; border-radius: 6px;
            transition: 0.1s;
        }
        .btn:active { transform: scale(0.96); }
        .btn-green { border-color: #0f0; color: #0f0; background: rgba(0, 255, 0, 0.05); }
        .btn-rand { width: 100%; background: linear-gradient(90deg, #222, #333); margin-top: 5px; padding: 14px;}

        /* –¶–≤–µ—Ç–∞ */
        .c-red { color: #ff0055; } .c-green { color: #00ff55; }
        .c-blue { color: #0055ff; } .c-yellow { color: #ffcc00; }
    </style>
</head>
<body>

    <div id="hud-layer">
        <div id="fps-meter">FPS: 60</div>
        <button id="btn-gear" onclick="UI.toggleMenu()">‚öôÔ∏è</button>
    </div>

    <div id="settings-overlay">
        <div id="settings-panel">
            <button id="btn-close" onclick="UI.toggleMenu()">‚úï</button>

            <h2>–ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç</h2>
            <div class="presets-grid">
                <button class="btn btn-green" onclick="Presets.load('snake')">üêç –ó–º–µ–∏</button>
                <button class="btn btn-green" onclick="Presets.load('cell')">ü¶† –ö–ª–µ—Ç–∫–∏</button>
                <button class="btn btn-green" onclick="Presets.load('galaxy')">üåå –ì–∞–ª–∞–∫—Ç–∏–∫–∏</button>
                <button class="btn btn-green" onclick="Presets.load('chaos')">üí• –•–∞–æ—Å</button>
            </div>

            <h2>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –º–∏—Ä–∞</h2>
            <div class="control-group">
                <label>–ß–∞—Å—Ç–∏—Ü: <span id="v-count" class="val">1000</span></label>
                <input type="range" min="200" max="2500" step="100" value="1000" oninput="UI.updCount(this.value)">
            </div>
            <div class="control-group">
                <label>–ó—Ä–µ–Ω–∏–µ: <span id="v-radius" class="val">80</span></label>
                <input type="range" min="10" max="200" value="80" oninput="Sim.radius = Number(this.value); UI.updText('radius', this.value)">
            </div>
            <div class="control-group">
                <label>–¢—Ä–µ–Ω–∏–µ: <span id="v-friction" class="val">0.5</span></label>
                <input type="range" min="0.01" max="0.99" step="0.01" value="0.5" oninput="Sim.friction = Number(this.value); UI.updText('friction', this.value)">
            </div>
            <div class="control-group">
                <label>–û—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ: <span id="v-repel" class="val">1.0</span></label>
                <input type="range" min="0.1" max="5.0" step="0.1" value="1.0" oninput="Sim.beta = Number(this.value); UI.updText('repel', this.value)">
            </div>

            <h3>–ú–∞—Ç—Ä–∏—Ü–∞ –í–ª–∏—è–Ω–∏—è</h3>
            <div class="matrix-grid" id="matrix-container"></div>
            <button class="btn btn-rand" onclick="Sim.randomizeRules()">üé≤ –°–ª—É—á–∞–π–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞</button>
            <div style="height: 20px;"></div> <!-- –û—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É -->
        </div>
    </div>

    <canvas id="canvas"></canvas>

<script>
    const COLORS = ['#ff0055', '#00ff55', '#0055ff', '#ffcc00'];
    const TYPES = 4;

    const Sim = {
        canvas: document.getElementById('canvas'),
        ctx: document.getElementById('canvas').getContext('2d', { alpha: false }),
        w: 0, h: 0,
        particles: [],
        count: 1000,
        radius: 80, friction: 0.5, beta: 1.0,
        rules: [],

        init() {
            this.resize();
            window.addEventListener('resize', () => this.resize());

            // –ò–Ω–∏—Ç –º–∞—Ç—Ä–∏—Ü—ã
            for(let i=0; i<TYPES; i++) {
                this.rules[i] = [];
                for(let j=0; j<TYPES; j++) this.rules[i][j] = 0;
            }

            this.createParticles();
            UI.buildMatrix();
            Presets.load('snake'); 

            this.loop = this.loop.bind(this);
            requestAnimationFrame(this.loop);
        },

        resize() {
            this.w = window.innerWidth;
            this.h = window.innerHeight;
            this.canvas.width = this.w;
            this.canvas.height = this.h;
        },

        createParticles() {
            this.particles = [];
            for(let i=0; i<this.count; i++) {
                this.particles.push({
                    x: Math.random() * this.w,
                    y: Math.random() * this.h,
                    vx: 0, vy: 0,
                    type: Math.floor(Math.random() * TYPES)
                });
            }
        },

        randomizeRules() {
            for(let i=0; i<TYPES; i++) {
                for(let j=0; j<TYPES; j++) {
                    this.rules[i][j] = Number((Math.random() * 2 - 1).toFixed(2));
                }
            }
            UI.syncMatrixInputs();
        },

        update() {
            const rMaxSq = this.radius * this.radius;
            const forceFactor = 0.5;
            const minDist = this.radius * 0.2;

            for (let i = 0; i < this.particles.length; i++) {
                let p1 = this.particles[i];
                let fx = 0, fy = 0;

                for (let j = 0; j < this.particles.length; j++) {
                    if (i === j) continue;
                    let p2 = this.particles[j];
                    let dx = p2.x - p1.x;
                    let dy = p2.y - p1.y;

                    if (dx > this.w * 0.5) dx -= this.w;
                    if (dx < -this.w * 0.5) dx += this.w;
                    if (dy > this.h * 0.5) dy -= this.h;
                    if (dy < -this.h * 0.5) dy += this.h;

                    const distSq = dx*dx + dy*dy;
                    if (distSq > 0 && distSq < rMaxSq) {
                        const dist = Math.sqrt(distSq);
                        let f = 0;
                        if (dist < minDist) {
                            f = this.beta * (dist / minDist - 1);
                        } else {
                            const ratio = (dist - minDist) / (this.radius - minDist);
                            f = this.rules[p1.type][p2.type] * (1 - Math.abs(2 * ratio - 1));
                        }
                        fx += (dx / dist) * f * forceFactor;
                        fy += (dy / dist) * f * forceFactor;
                    }
                }
                p1.vx = (p1.vx + fx) * this.friction;
                p1.vy = (p1.vy + fy) * this.friction;
                p1.x += p1.vx; p1.y += p1.vy;

                if (p1.x < 0) p1.x += this.w;
                if (p1.x > this.w) p1.x -= this.w;
                if (p1.y < 0) p1.y += this.h;
                if (p1.y > this.h) p1.y -= this.h;
            }
        },

        draw() {
            this.ctx.globalCompositeOperation = 'source-over';
            this.ctx.fillStyle = 'rgba(5, 5, 5, 0.35)'; // –ß—É—Ç—å –º–µ–Ω—å—à–µ —à–ª–µ–π—Ñ –¥–ª—è —á–µ—Ç–∫–æ—Å—Ç–∏ –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ
            this.ctx.fillRect(0, 0, this.w, this.h);
            this.ctx.globalCompositeOperation = 'lighter';

            for(let i=0; i<this.particles.length; i++) {
                let p = this.particles[i];
                this.ctx.fillStyle = COLORS[p.type];
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 2.5, 0, Math.PI*2); // –ß—É—Ç—å –∫—Ä—É–ø–Ω–µ–µ
                this.ctx.fill();
            }
        },

        lastTime: 0,
        loop(timestamp) {
            const dt = timestamp - this.lastTime;
            if(dt > 0) document.getElementById('fps-meter').innerText = 'FPS: ' + Math.round(1000/dt);
            this.lastTime = timestamp;
            this.update();
            this.draw();
            requestAnimationFrame(this.loop);
        }
    };

    const UI = {
        menuOpen: false,
        toggleMenu() {
            this.menuOpen = !this.menuOpen;
            const el = document.getElementById('settings-overlay');
            el.style.display = this.menuOpen ? 'flex' : 'none';
        },

        buildMatrix() {
            const container = document.getElementById('matrix-container');
            container.innerHTML = '';
            container.appendChild(this.createEl('div', ''));
            COLORS.forEach((c, i) => {
                let el = this.createEl('div', '‚ñ†', 'matrix-header');
                el.style.color = c; container.appendChild(el);
            });
            for(let i=0; i<TYPES; i++) {
                let label = this.createEl('div', '‚ñ†', 'matrix-header');
                label.style.color = COLORS[i]; container.appendChild(label);
                for(let j=0; j<TYPES; j++) {
                    let cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    let input = document.createElement('input');
                    input.type = 'number'; input.step = 0.1; input.min = -2; input.max = 2;
                    input.value = Sim.rules[i][j];
                    input.id = `rule-${i}-${j}`;
                    input.onchange = (e) => Sim.rules[i][j] = Number(e.target.value);
                    cell.appendChild(input);
                    container.appendChild(cell);
                }
            }
        },

        createEl(tag, txt, cls) {
            let e = document.createElement(tag);
            if(txt) e.innerText = txt;
            if(cls) e.className = cls;
            return e;
        },

        syncMatrixInputs() {
            for(let i=0; i<TYPES; i++) for(let j=0; j<TYPES; j++) 
                document.getElementById(`rule-${i}-${j}`).value = Sim.rules[i][j];
        },

        updText(id, val) { document.getElementById('v-'+id).innerText = val; },
        updCount(val) { this.updText('count', val); Sim.count = Number(val); Sim.createParticles(); }
    };

    const Presets = {
        setParams(rad, fric, beta) {
            Sim.radius = rad; document.querySelector('input[oninput*="Sim.radius"]').value = rad; UI.updText('radius', rad);
            Sim.friction = fric; document.querySelector('input[oninput*="Sim.friction"]').value = fric; UI.updText('friction', fric);
            Sim.beta = beta; document.querySelector('input[oninput*="Sim.beta"]').value = beta; UI.updText('repel', beta);
        },

        load(name) {
            for(let i=0; i<TYPES; i++) for(let j=0; j<TYPES; j++) Sim.rules[i][j] = 0;

            if (name === 'snake') {
                this.setParams(80, 0.5, 1.0);
                Sim.rules[0][0]=1; Sim.rules[0][1]=1; 
                Sim.rules[1][1]=1; Sim.rules[1][2]=1; 
                Sim.rules[2][2]=1; Sim.rules[2][3]=1;
                Sim.rules[3][3]=1; Sim.rules[3][0]=1;
                Sim.rules[0][2]=-0.5; Sim.rules[1][3]=-0.5;
            }
            else if (name === 'cell') {
                this.setParams(60, 0.15, 2.0);
                for(let i=0; i<TYPES; i++) for(let j=0; j<TYPES; j++) 
                    Sim.rules[i][j] = (i===j) ? 0.8 : -0.6;
            }
            else if (name === 'galaxy') {
                this.setParams(150, 0.5, 5.0);
                for(let i=0; i<TYPES; i++) for(let j=0; j<TYPES; j++) Sim.rules[i][j] = 0.5;
                Sim.rules[0][1] = 1.0; Sim.rules[1][0] = 0.2;
            }
            else if (name === 'chaos') {
                this.setParams(100, 0.6, 1.0);
                Sim.randomizeRules();
            }

            UI.syncMatrixInputs();
            Sim.createParticles();
            // –ó–∞–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ –ø—Ä–µ—Å–µ—Ç–∞
            if(UI.menuOpen) UI.toggleMenu();
        }
    };

    Sim.init();
</script>
</body>
</html>