<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magnet Breaker Chaos</title>
    <style>
        body { margin: 0; background: #111; overflow: hidden; font-family: sans-serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui {
            position: absolute; top: 20px; left: 0; width: 100%;
            text-align: center; pointer-events: none;
            color: #fff; text-transform: uppercase;
            text-shadow: 0 0 10px #000;
        }
        #score { font-size: 40px; font-weight: 900; letter-spacing: 2px; }
        #hint { font-size: 14px; opacity: 0.7; margin-top: 10px; color: #0f0; }

        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
    </style>
</head>
<body>

<div id="ui">
    <div id="score">0</div>
    <div id="hint">ЗАЖМИ ЧТОБЫ ПРИТЯНУТЬ <br> ОТПУСТИ ЧТОБЫ ВЫСТРЕЛИТЬ</div>
</div>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// --- НАСТРОЙКИ ---
let W, H;
let score = 0;
let balls = [];
let particles = [];
let blocks = [];
let buffs = [];
let magnetActive = false;
let shakeTime = 0;

// Платформа
const paddle = {
    x: 0, y: 0, w: 120, h: 20,
    color: '#00ffff',
    capturedBalls: [] // Мячи, которые прилипли
};

// Цвета для неона
const COLORS = ['#ff0055', '#00ff55', '#0055ff', '#ffff00', '#ff00ff'];

// --- ИНИЦИАЛИЗАЦИЯ ---
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    paddle.y = H - 100;
    paddle.x = W / 2 - paddle.w / 2;
    initLevel();
}
window.addEventListener('resize', resize);

function initLevel() {
    blocks = [];
    const cols = 8;
    const rows = 6;
    const padding = 10;
    const blockW = (W - padding * 2) / cols - padding;
    const blockH = 30;

    for(let r=0; r<rows; r++) {
        for(let c=0; c<cols; c++) {
            blocks.push({
                x: padding + c * (blockW + padding),
                y: 80 + r * (blockH + padding),
                w: blockW, h: blockH,
                color: COLORS[r % COLORS.length],
                active: true,
                hp: 1 // Можно сделать прочные блоки
            });
        }
    }

    // Стартовый мяч
    if(balls.length === 0) spawnBall(W/2, H/2);
}

function spawnBall(x, y, vx, vy) {
    balls.push({
        x: x, y: y,
        vx: vx || (Math.random() - 0.5) * 8,
        vy: vy || -8,
        r: 8,
        color: '#fff',
        trail: [],
        stuck: false // Прилип ли к платформе
    });
}

// --- УПРАВЛЕНИЕ ---
function inputStart(e) {
    magnetActive = true;
    e.preventDefault();
}

function inputEnd(e) {
    magnetActive = false;
    releaseBalls();
    e.preventDefault();
}

function inputMove(e) {
    let clientX = e.touches ? e.touches[0].clientX : e.clientX;
    paddle.x = clientX - paddle.w / 2;

    // Ограничение краев
    if(paddle.x < 0) paddle.x = 0;
    if(paddle.x + paddle.w > W) paddle.x = W - paddle.w;
}

canvas.addEventListener('mousedown', inputStart);
canvas.addEventListener('mouseup', inputEnd);
canvas.addEventListener('mousemove', inputMove);

canvas.addEventListener('touchstart', inputStart, {passive: false});
canvas.addEventListener('touchend', inputEnd, {passive: false});
canvas.addEventListener('touchmove', inputMove, {passive: false});

// --- ЛОГИКА ---
function releaseBalls() {
    // Выстреливаем "дробовиком"
    // Чем больше мячей накопили, тем быстрее они летят
    let power = 10 + Math.min(balls.length, 10); 

    balls.forEach(b => {
        if(b.stuck) {
            b.stuck = false;
            // Случайный разброс вверх
            let angle = -Math.PI/2 + (Math.random() - 0.5) * 1.0; // Конус 60 градусов
            b.vx = Math.cos(angle) * power;
            b.vy = Math.sin(angle) * power;
        }
    });
}

function createExplosion(x, y, color) {
    // Тряска экрана
    shakeTime = 10;

    for(let i=0; i<15; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 1.0,
            color: color
        });
    }
}

function spawnBuff(x, y) {
    // 20% шанс выпадения баффа
    if(Math.random() > 0.2) return;

    const types = ['SPLIT', 'BIG'];
    const type = types[Math.floor(Math.random() * types.length)];

    buffs.push({
        x: x, y: y, w: 20, h: 20,
        type: type,
        vy: 3
    });
}

function applyBuff(type) {
    if(type === 'SPLIT') {
        // Умножаем мячи!
        let currentCount = balls.length;
        if (currentCount < 100) { // Ограничитель, чтобы браузер не умер
            for(let i=0; i<currentCount; i++) {
                let b = balls[i];
                spawnBall(b.x, b.y, -b.vx, b.vy); // Копия в другую сторону
            }
        }
        document.getElementById('hint').innerText = "MULTIBALL CHAOS!";
        setTimeout(() => document.getElementById('hint').innerText = "", 1000);
    } 
    else if (type === 'BIG') {
        paddle.w += 20;
    }
}

function update() {
    // Тряска экрана
    let shakeX = 0, shakeY = 0;
    if(shakeTime > 0) {
        shakeTime--;
        shakeX = (Math.random() - 0.5) * 10;
        shakeY = (Math.random() - 0.5) * 10;
    }

    // Блоки
    let activeBlocks = 0;
    blocks.forEach(b => {
        if(b.active) activeBlocks++;
    });
    if(activeBlocks === 0) initLevel(); // Рестарт уровня

    // Мячи
    for(let i = balls.length - 1; i >= 0; i--) {
        let b = balls[i];

        // 1. Логика Магнита
        if (b.stuck) {
            // Если прилип, двигается вместе с платформой
            // Слегка стягиваем их к центру платформы
            let targetX = paddle.x + paddle.w/2;
            b.x += (targetX - b.x) * 0.1;
            b.y = paddle.y - b.r;
            continue; // Пропускаем физику
        }

        if (magnetActive) {
            // Если магнит включен и мяч близко -> притягиваем
            let dx = (paddle.x + paddle.w/2) - b.x;
            let dy = paddle.y - b.y;
            let dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < 250 && b.y < paddle.y) { // Радиус действия 250px
                b.vx += dx * 0.005;
                b.vy += dy * 0.005;
                b.color = '#00ffff'; // Синеет под магнитом
            } else {
                b.color = '#fff';
            }
        }

        // 2. Движение
        b.x += b.vx;
        b.y += b.vy;

        // Шлейф
        b.trail.push({x: b.x, y: b.y});
        if(b.trail.length > 10) b.trail.shift();

        // 3. Стены
        if(b.x < 0 || b.x > W) { b.vx *= -1; b.x = b.x < 0 ? 0 : W; }
        if(b.y < 0) { b.vy *= -1; b.y = 0; }

        // Дно (Смерть мяча)
        if(b.y > H) {
            balls.splice(i, 1);
            if(balls.length === 0) {
                score = 0; document.getElementById('score').innerText = score;
                spawnBall(W/2, H/2); // Респаун
            }
            continue;
        }

        // 4. Коллизия с Платформой
        if(b.y + b.r >= paddle.y && b.y - b.r <= paddle.y + paddle.h &&
           b.x >= paddle.x && b.x <= paddle.x + paddle.w) {

            if(magnetActive) {
                b.stuck = true;
                b.vx = 0; b.vy = 0;
            } else {
                // Обычный отскок
                b.vy = -Math.abs(b.vy);
                // Добавляем скорость платформы
                let hitPoint = (b.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
                b.vx += hitPoint * 5; 
                // Ускоряем мяч немного
                b.vx *= 1.05; b.vy *= 1.05;
            }
        }

        // 5. Коллизия с Блоками
        blocks.forEach(block => {
            if(!block.active) return;

            if(b.x > block.x && b.x < block.x + block.w &&
               b.y > block.y && b.y < block.y + block.h) {

                block.active = false;
                b.vy *= -1;
                score += 10;
                document.getElementById('score').innerText = score;

                createExplosion(block.x + block.w/2, block.y + block.h/2, block.color);
                spawnBuff(block.x + block.w/2, block.y + block.h/2);
            }
        });
    }

    // Баффы
    for(let i = buffs.length - 1; i >= 0; i--) {
        let f = buffs[i];
        f.y += f.vy;

        // Поймали бафф
        if(f.y + f.h >= paddle.y && f.x >= paddle.x && f.x <= paddle.x + paddle.w) {
            applyBuff(f.type);
            buffs.splice(i, 1);
        } else if (f.y > H) {
            buffs.splice(i, 1);
        }
    }

    // Частицы
    for(let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.05;
        if(p.life <= 0) particles.splice(i, 1);
    }

    return {x: shakeX, y: shakeY};
}

function draw(shake) {
    ctx.save();
    ctx.translate(shake.x, shake.y); // Тряска

    // Очистка с блюром для шлейфов
    ctx.fillStyle = 'rgba(17, 17, 17, 0.3)';
    ctx.fillRect(-10, -10, W+20, H+20);

    // Блоки
    blocks.forEach(b => {
        if(!b.active) return;
        ctx.fillStyle = b.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = b.color;
        ctx.fillRect(b.x, b.y, b.w-2, b.h-2);
        ctx.shadowBlur = 0;
    });

    // Платформа
    ctx.fillStyle = magnetActive ? '#fff' : paddle.color;
    ctx.shadowBlur = magnetActive ? 20 : 0;
    ctx.shadowColor = '#00ffff';
    ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

    // Эффект магнита (линии)
    if(magnetActive) {
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(paddle.x + paddle.w/2, paddle.y, 250, Math.PI, 0); // Дуга радиуса
        ctx.stroke();
    }

    // Мячи
    balls.forEach(b => {
        // Шлейф
        if(b.trail.length > 0) {
            ctx.beginPath();
            ctx.strokeStyle = b.color;
            ctx.lineWidth = 2;
            ctx.moveTo(b.trail[0].x, b.trail[0].y);
            for(let t of b.trail) ctx.lineTo(t.x, t.y);
            ctx.stroke();
        }

        ctx.fillStyle = b.color;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fill();
    });

    // Баффы
    buffs.forEach(f => {
        ctx.fillStyle = f.type === 'SPLIT' ? '#ff00ff' : '#00ff00';
        ctx.font = "20px sans-serif";
        ctx.fillText(f.type === 'SPLIT' ? '✖' : '▲', f.x, f.y);
    });

    // Частицы
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fillRect(p.x, p.y, 4, 4);
        ctx.globalAlpha = 1;
    });

    ctx.restore();
}

function loop() {
    let shake = update();
    draw(shake);
    requestAnimationFrame(loop);
}

resize();
loop();

</script>
</body>
</html>
